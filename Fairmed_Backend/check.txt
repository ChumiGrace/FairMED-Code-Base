import os

from rest_framework import serializers
from Fairmed_Backend.settings import BASE_DIR
from registration.models import *
from rate_and_review.models import *


from . models import *
from medical_record.models import *


class PhysicianListSerializer(serializers.ModelSerializer):
    class Meta:
        model = PhysicianModel
        fields = (
            'id',
            'name',
            'phone', 
            'email',
            'av_rate',
        )

    
class HealthCenterListSerializer(serializers.ModelSerializer):
    class Meta:
        model = HealthCenterModel
        fields = (
            'id',
            'name',
            'av_rate',
        )

class PhysicianSerializer(serializers.ModelSerializer):
    class Meta:
        model = PhysicianModel
        fields = (
            'id',
            'name',
            'email',
            'phone'
            'av_rate',
            'getRecentReviews'
        )
class PatientSerializer(serializers.ModelSerializer):
    medical_records = serializers.SerializerMethodField()
    class Meta:
        model = PatientModel
        fields = (
            'id',
            'name',
            'email',
            'phone',
            'medical_records'
        )

    def get_medical_records(self, obj):
        med_rec = []
        records = MedicalRecords.objects.filter(patientId = obj)

        for rec in records:
            med_rec.append(rec.record)
        return med_rec

class HealthCenterSerializer(serializers.ModelSerializer):
    class Meta:
        model = HealthCenterModel
        fields = (
            'rate',
            'getRecentReviews'
        )

# class RecentPhysicianSerializer(serializers.ModelSerializer):
#     patientName = serializers.SerializerMethodField()
#     class Meta:
#         model = PhysicianRatesAndReviews
#         fields = (
#             'patientName',
#             'rate',
#             'review'
#         )

    def get_patientName(self, obj):
        return obj.patientId.name if obj.patientId else None


class RecentHealthCenterSerializer(serializers.ModelSerializer):
    patientName = serializers.SerializerMethodField()
    class Meta:
        model = PhysicianRatesAndReviews
        fields = (
            'patientName',
            'rate',
            'review'
        )

    def get_patientName(self, obj):
        return obj.patientId.name if obj.patientId else None
    
class PhysicianDetailSerializer(serializers.ModelSerializer):
    reviews = serializers.SerializerMethodField()
    class Meta:
        model = PhysicianModel
        fields = (
            'id',
            'name',
            ''
        )
from django.urls import path
from .import views

app_name = 'home'

urlpatterns = [
    path('physicians_reviews_rates/', views.BrowsePhysiciansRate.as_view()),
    path('physicians_reviews_rates/<int:physicianId>/', views.PhysicianDetailView.as_view()),
    path('hcs_reviews_rates/', views.BrowseHealthCentersRate.as_view()),
    path('hcs_reviews_rates/<int:hcId>/', views.HealthCenterDetailView.as_view()),
    path('patient_profile/<int:user_id>/', views.PatientProfile.as_view()),
    path('physician_profile/<int:user_id>/', views.PhysicianProfile.as_view())
]
 from rest_framework.exceptions import MethodNotAllowed
from django.shortcuts import render
from django import views
from django.http import HttpResponse
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.filters import (SearchFilter, OrderingFilter)

from rest_framework.response import Response
from rest_framework import generics
from rest_framework.decorators import api_view, authentication_classes
from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated

from .models import *
from rate_and_review.models import *
from rate_and_review.forms import *
from registration.models import *
from .serializers import *
from registration.authentication_backends import *


class BrowsePhysiciansRate(generics.ListCreateAPIView):
    """To generate a list of physicians with their definitive rates and reviews"""
    
    queryset = PhysicianModel.objects.all()
    serializer_class = PhysicianListSerializer
    filter_backends = [SearchFilter, OrderingFilter]
    search_fields = ('name',)
    

    def post(self, request, *args, **kwargs):
        raise MethodNotAllowed('POST')
    

class PhysicianDetailView(APIView):
    """Physician's detail view to be presented to any user when the profile is clicked!"""
    
    def get(self, request, physicianId):
        physician = PhysicianModel.objects.get(id = physicianId)
        rec_rev = json.loads(physician.recent_reviews)
        data = {
            'name': physician.name,
            'email': physician.email,
            'phone': physician.phone,
            'rate': physician.av_rate,
            'reviews': rec_rev,
        }

        return Response(data)

    
class BrowseHealthCentersRate(generics.ListCreateAPIView):
    """To generate a list of health centers with their definitive rates and reviews"""
    filter_backends = [SearchFilter, OrderingFilter]
    search_fields = ('name',)

    queryset = HealthCenterModel.objects.all()
    serializer_class = HealthCenterListSerializer

    def post(self, request, *args, **kwargs):
        raise MethodNotAllowed('POST')
    

class HealthCenterDetailView(APIView):
    """Physician's detail view to be presented to any user when the profile is clicked!"""
    
    def get(self, request, hcId):
        hc = HealthCenterModel.objects.get(id = hcId)
        rec_rev = json.loads(hc.recent_reviews)
        data = {
            'name': hc.name,
            'email': hc.email,
            'rate': hc.av_rate,
            'reviews': rec_rev,
        }

        return Response(data)

"""Patient's detail view to be shown in the patient's dashboard!"""
class PatientProfile(APIView):
    authentication_classes = [PatientJWTAuthentication]
    permission_classes = [IsAuthenticated]
    
    def get(self, request, user_id):
        user = request.user
        data = PatientSerializer(user).data


        return Response(data)
    
    def put(self, request, user_id):
        """For Updating Profile!"""
        patient = request.user
        if request.data:
            try:
                if request.data['name']:
                    patient.name = request.data['name']
            except:
                pass
            try:
                if request.data['email']:
                    patient.email = request.data['email']
            except:
                pass
            patient.save()
            return Response(PatientSerializer(patient).data)
        else:
            return Response(None)
"""Physician's detail view to be shown in the physician's dashboard!"""
class PhysicianProfile(APIView):
    authentication_classes = [PhysicianJWTAuthentication]
    permission_classes = [IsAuthenticated]
    def get(self, request, user_id):
        user = request.user
        data = PhysicianSerializer(user).data


        return Response(data)
    
    def put(self, request):
        """For Updating Profile!"""
        physician = request.user
        if request.data:
            try:
                if request.data['name']:
                    physician.name = request.data['name']
            except:
                pass
            try:
                if request.data['email']:
                    physician.email = request.data['email']
            except:
                pass
            physician.save()
            return Response(PhysicianSerializer(physician).data)
        else:
            return Response(None)


from django import forms
from registration.models import *


class PatientLoginForm(forms.ModelForm):
    class Meta:
        model = PatientModel
        fields = (
            'name',
            'email',
            'password',
        )

class PhysicianLoginForm(forms.ModelForm):
    class Meta:
        model = PhysicianModel
        fields = (
            'name',
            'email',
            'password',
        )from django.urls import path
from . import views
# from .views import PhysicianTokenObtainPairView

app_name = 'login'

urlpatterns = [
    path('patient/', views.PatientAuthenticationView.as_view(), name='patient'),
    path('physician/', views.PhysicianAuthenticationView.as_view(), name='physician'),
    path('api/token/', views.dataFromFingerPrint),
    # path('api/token/exam/', views.ExampleProtectedView.as_view())
]
from registration.authentication_backends import *
from django.contrib.auth import authenticate
from django.contrib.auth.models import update_last_login
from rest_framework import generics
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer
from rest_framework_simplejwt.views import TokenObtainPairView
from rest_framework.settings import api_settings
from rest_framework.permissions import IsAuthenticated
from rest_framework.views import APIView
from django.views.decorators.csrf import csrf_exempt
from rest_framework.decorators import api_view
from django.contrib.auth.hashers import make_password
import requests




from .forms import *
from registration.models import PatientModel, PhysicianModel
from django.http import HttpResponse
from registration.serializers import *

from rest_framework.response import Response



class PatientAuthenticationView(APIView):
    authentication_classes = [PatientJWTAuthentication]

    def get(self, request):
        print(request.user)
        return Response({'message': 'This is Authenticated User!'})
    
    def post(self, request):
        """There are expected modifications in the return data, since the data should
        contain the refresh token as well!
        The view also has to be changed into class based view!
        """
        # name = request.POST.get('name')
        # email = request.POST.get('email')
        # password = request.POST.get('password')

        # name = request.data['name']
        email = request.data['email']
        password = request.data['password']

        user = authenticate(request=request, email = email, password = password, acc_type = 'patient')

        if not user:
            message = 'The information you provided was not correct! RETRY with the correct info!'
            return Response ({'message': message})
        else:
            if api_settings.UPDATE_LAST_LOGIN:
                update_last_login(None, user)            

            data = user.jwt_token
            res = {
                'token':data
            }
            return Response(res)
        


class PhysicianAuthenticationView(APIView):
    authentication_classes = [PhysicianJWTAuthentication]

    def get(self, request):
        print(request.user)
        return Response({'message': 'This is Authenticated User!'})
    
    def post(self, request):
        """There are expected modifications in the return data, since the data should
        contain the refresh token as well!
        The view also has to be changed into class based view!(dec 30th)
        """
        name = request.POST.get('name')
        email = request.POST.get('email')
        password = request.POST.get('password')

        user = authenticate(request=request, email = email, password = password, acc_type = 'physician')

        if not user:
            message = 'The information you provided was not correct! RETRY with the correct info!'
            return Response ({'message': message})
        else:
            if api_settings.UPDATE_LAST_LOGIN:
                update_last_login(None, user)            

            data = user.jwt_token
            return Response(data)
        
@csrf_exempt
@api_view(['POST'])
def dataFromFingerPrint(request):
    if request.method == 'POST':
        print(request.data)
        return Response({'message': 'I have recieved the data!'})


    
# ----------request-------------
# import requests

# def requ(data):
#     endpoint = 'http://10.6.156.61:8080'
#     res = requests.post(endpoint, json={'mes':data})

# requ('Hey')
#-----------request-------------

        

from django import forms


from . models import *


class RecordCreationForm(forms.ModelForm):
    class Meta:
        model = MedicalRecords
        fields = (
            'record',
        )from django.db import models

from registration.models import *

class MedicalRecords(models.Model):
    patientId = models.ForeignKey(PatientModel, on_delete = models.CASCADE)
    recordId = models.AutoField(primary_key= True)
    record = models.TextField(null = True)
    date_created = models.DateTimeField(auto_now_add = True)
    physicianId = models.ForeignKey(PhysicianModel, on_delete = models.SET_NULL, null = True)
    hcId = models.ForeignKey(HealthCenterModel, on_delete = models.SET_NULL, null = True)
from rest_framework import serializers

from . models import *


class MedRecSerializer(serializers.Serializer):
    class Meta:
        model = MedicalRecords
        fields = ('id','patientId__name','record')

    from django.urls import path
from django.conf import settings
from django.conf.urls.static import static


from . import views

app_name = 'medical_record'

urlpatterns = [
   path('create/', views.CreatePatientRecord.as_view(), name='create_record'),
   path('view/', views.PatientRecord.as_view(), name='view_record')

]



if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)from django.shortcuts import render
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework import generics
from rest_framework.decorators import api_view
from rest_framework.permissions import IsAuthenticated
from registration.authentication_backends import PhysicianJWTAuthentication


from . forms import *
from . models import *
from . serializers import *

class PatientRecord(APIView):
    authentication_classes = [PhysicianJWTAuthentication]
    permission_classes = [IsAuthenticated]
    def post(self, request):
        form = RecordCreationForm(request.data)

        if form.is_valid():
            patientId = request.data['patient_id']
            patientName = request.data['patient_name']
            patient = PatientModel.objects.get(id = patientId)
            if patient.name == patientName:
                recs = MedicalRecords.objects.filter(patientId = patient)
                rec_list = MedRecSerializer(recs)
                return Response(rec_list, status=200)
            else:
                return Response({'Error:':'Authentication error Provide the correct information!'})
        return Response(form.errors, status=400)
    
def setMedRec(patient):
    try:
        recs = MedicalRecords.objects.filter(patientId = patient.id)
        patient.records = json.dumps(recs)
        patient.save()
        return patient
    except:
        return TypeError

    
class CreatePatientRecord(APIView):
    authentication_classes = [PhysicianJWTAuthentication]
    permission_classes = [IsAuthenticated]
    def post(self, request):
        form = RecordCreationForm(request.data)

        if form.is_valid():
            record = form.cleaned_data['record']
            patientId = request.data['patient_id']
            patient = PatientModel.objects.get(id = patientId)
            physician = request.user
            hc = physician.hcId

            med_rec = MedicalRecords.objects.create(record = record, patientId = patient, physicianId = physician, hcId = hc)
            med_rec.save()

            setMedRec(patient)            

            rec = MedicalRecords.objects.get(recordId = med_rec.recordId)

            recordId = rec.recordId
            patient_name = rec.patientId.name
            physician_name = rec.physicianId.name
            hc_name = rec.hcId.name
            
            data = {
                'name': patient_name,
                'Treated by': physician_name,
                'Health center': hc_name,
                'recordId': recordId
            }

            return Response(data=data, status= 201)
        else:
            return Response(form.errors, status=400)
        
from django import forms 

from .models import *

class CreatePhysicianReviewForm(forms.ModelForm):
    class Meta:
        model = PhysicianRatesAndReviews
        fields = ('rate', 'review')

class CreateHealthCenterReviewForm(forms.ModelForm):
    class Meta:
        model = HealthCenterRatesAndReviews
        fields = ('rate', 'review')from django.db import models

from registration.models import *



class PhysicianRatesAndReviews(models.Model):
    reviewId = models.AutoField(primary_key=True)
    physicianId = models.ForeignKey(PhysicianModel, on_delete=models.CASCADE)
    rate = models.DecimalField(max_digits=5, decimal_places=4)
    review = models.TextField(max_length = 400)
    patientId = models.ForeignKey(PatientModel, null = True, on_delete = models.SET_NULL)
    date_created = models.DateField(auto_now_add=True)

    @property
    def getPatientName(self):
        return self.patientId.name
    
    @property
    def getPhysicianName(self):
        return self.physicianId.name


class HealthCenterRatesAndReviews(models.Model):
    reviewId = models.AutoField(primary_key=True)
    hcId = models.ForeignKey(HealthCenterModel, on_delete=models.CASCADE)
    rate = models.DecimalField(max_digits=5, decimal_places=4)
    review = models.TextField(max_length = 400)
    patientId = models.ForeignKey(PatientModel, null = True, on_delete = models.SET_NULL)
    date_created = models.DateField(auto_now_add=True)


    @property
    def getPatientName(self):
        return self.patientId.name
    
    
    @property
    def getHealthcenterName(self):
        return self.hcId.name
    
from rest_framework import serializers


from . models import *


class PhysicianListSerializer(serializers.ModelSerializer):
    class Meta:
        model = PhysicianRatesAndReviews
        fields = (
            'getPatientName',
            'getPhysicianName',
            'rate',
            'review',
            'date_created',
        )

    
class HealthCenterListSerializer(serializers.ModelSerializer):
    class Meta:
        model = HealthCenterRatesAndReviews
        fields = (
            'getPatientName',
            'getHealthcenterName',
            'rate',
            'review',
            'date_created',
        )

class PhysicianSerializer(serializers.ModelSerializer):
    class Meta:
        model = PhysicianModel
        fields = (
            'rate',
            'getRecentReviews'
        )

class HealthCenterSerializer(serializers.ModelSerializer):
    class Meta:
        model = HealthCenterModel
        fields = (
            'rate',
            'getRecentReviews'
        )

    

class RecentPhysicianSerializer(serializers.ModelSerializer):
    patientName = serializers.SerializerMethodField()
    class Meta:
        model = PhysicianRatesAndReviews
        fields = (
            'patientName',
            'rate',
            'review'
        )

    

    def get_patientName(self, obj):
        return obj.patientId.name if obj.patientId else None


class RecentHealthCenterSerializer(serializers.ModelSerializer):
    patientName = serializers.SerializerMethodField()
    class Meta:
        model = PhysicianRatesAndReviews
        fields = (
            'patientName',
            'rate',
            'review'
        )

    def get_patientName(self, obj):
        return obj.patientId.name if obj.patientId else None
    
from django.urls import path

from . import views

app_name = 'rate_and_review'

urlpatterns = [
    path('', views.CreateRateAndReview.as_view(), name='create'),
]
from rest_framework.exceptions import MethodNotAllowed
from django.shortcuts import render
from django import views
from django.http import HttpResponse

from rest_framework.response import Response
from rest_framework import generics
from rest_framework.decorators import api_view
from rest_framework.views import APIView

from .models import *
from .forms import *
from registration.models import *
from .serializers import *



def setRecentReviews(entity, entity_type):
    if entity_type == 'physician':
        recentQuerySet = PhysicianRatesAndReviews.objects.filter(physicianId = entity.id).order_by('date_created')[:5]
        rec_list = []
        for rev in recentQuerySet:
            recentRev = RecentPhysicianSerializer(rev).data
            rec_list.append(recentRev)

        rec_reviews = json.dumps(rec_list)

        physician = PhysicianModel.objects.get(id = entity.id)
        physician.recent_reviews = rec_reviews

        physician.save()

    elif entity_type == 'health_center':
        recentQuerySet = HealthCenterRatesAndReviews.objects.filter(hcId = entity.id).order_by('date_created').all()
        rec_list = []
        for rev in recentQuerySet:
            recentRev = RecentHealthCenterSerializer(rev).data
            rec_list.append(recentRev)

        rec_reviews = json.dumps(rec_list)

        hc = HealthCenterModel.objects.get(id = entity.id)
        hc.recent_reviews = rec_reviews

        hc.save()


    
def setAverageRate(entity, entity_type):
    if entity_type == 'physician':
        physicianRates = PhysicianRatesAndReviews.objects.filter(physicianId = entity.id)
        sum = 0
        for obj in physicianRates:
            sum += obj.rate
        average_rate = round(sum/len(physicianRates), 4)

        physician = PhysicianModel.objects.get(id = entity.id)
        physician.av_rate = average_rate
        physician.save()

    elif entity_type == 'health_center':
        hcRates = HealthCenterRatesAndReviews.objects.filter(hcId = entity.id)
        sum = 0
        for obj in hcRates:
            sum += obj.rate
        average_rate = round(sum/len(hcRates), 4)

        hc = HealthCenterModel.objects.get(id = entity.id)
        hc.av_rate = average_rate
        hc.save()


    
class CreateRateAndReview(APIView):
    """
    This view is specifically for creating rate and review for a physician or a health
    center. It accepts two http methods for now(dec 28). There might be modifications in
    future with additional features. 
    """
    def post(self, request):
        '''
        There are some modifications to be applied to this view(dec 30th). 
        
        The required data are:
            - The entity type to be rated and reviewed
            - The id number of the entity to be rated and reviewed
            - The id number of the patient rating
        the modification includes figuring out method to fetch these data from the request!
        '''
        form1 = CreatePhysicianReviewForm(request.data)
        form2 = CreateHealthCenterReviewForm(request.data)

        entity_type = request.data['entity_type']

        print(request.data['patient_id'])
        if form1.is_valid() and entity_type == 'physician':
            patientId = request.data['patient_id']
            patient = PatientModel.objects.get(id = patientId)
            physicianId = request.data['physician_id']
            physician = PhysicianModel.objects.get(id = physicianId)
            rate = form1.cleaned_data['rate']
            review = form1.cleaned_data['review']
            entity = PhysicianRatesAndReviews.objects.create(patientId = patient, physicianId = physician, rate = rate, review = review)
            entity.save()

            setAverageRate(physician, entity_type)
            setRecentReviews(physician, entity_type)

            serializer = PhysicianListSerializer(entity)

            return Response(serializer.data, status=201)
        
        elif form2.is_valid() and entity_type == 'health_center':
            patientId = request.data['patient_id']
            patient = PatientModel.objects.get(id = patientId)
            hcId = request.data['hc_id']
            hc = HealthCenterModel.objects.get(id = hcId)
            rate = form1.cleaned_data['rate']
            review = form1.cleaned_data['review']
            entity = HealthCenterRatesAndReviews.objects.create(patientId = patient, hcId = hc, rate = rate, review = review)
            entity.save()

            setAverageRate(hc, entity_type)
            setRecentReviews(hc, entity_type)


            serializer = PhysicianListSerializer(entity)

            return Response(serializer.data, status=201)
        return Response({'message':"The view didn't work correctly!"})"""
This module contains the custom authentication backends that will be used to authenticate
and authorize users according to their account types!

I used the custom authentication backends because our system has two types accounts 
which both of them need authentication, thus to use the default django authentication 
or DRF authentication class is not possible. 
"""


from .models import PatientModel, PhysicianModel
from rest_framework_simplejwt.tokens import RefreshToken
from django.contrib.auth import get_user_model
from rest_framework_simplejwt.authentication import JWTAuthentication
from rest_framework import permissions

class PhysicianJWTAuthentication(JWTAuthentication):
    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self.user_model = PhysicianModel

class PatientJWTAuthentication(JWTAuthentication):
    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self.user_model = PatientModel


class PatientAuthBackend:
    def authenticate(self, request, acc_type, email=None, password=None):
        if acc_type == 'patient':
            user = PatientModel.objects.filter(email=email).first()
            if user and user.check_password(password):
                refresh = RefreshToken.for_user(user)

                user.jwt_token = str(refresh.access_token)  # Store token in a custom field (jwt_token)
                user.save()
                return user
            return None
        return None

    def get_user(self, user_id):
        try:
            return PatientModel.objects.get(pk=user_id)
        except PatientModel.DoesNotExist:
            return None

class PhysicianAuthBackend:
    def authenticate(self, request, acc_type, email=None, password=None):
        if acc_type == 'physician':
            user = PhysicianModel.objects.filter(email=email).first()
            if user and user.check_password(password):
                refresh = RefreshToken.for_user(user)

                user.jwt_token = str(refresh.access_token)  # Store token in a custom field (jwt_token)
                user.save()
                return user
            return None
        return None

    def get_user(self, user_id):
        try:
            return PhysicianModel.objects.get(pk=user_id)
        except PhysicianModel.DoesNotExist:
            return None
        



from django import forms
from .models import *

class PatientRegForm(forms.ModelForm):
    password = forms.CharField(max_length=15, widget=forms.PasswordInput, label='Password:')
    password2 = forms.CharField(max_length=15, widget=forms.PasswordInput, label="Confirm Password:")
    class Meta:
        model = PatientModel
        fields = (
            'name', 
            'email', 
            'phone', 
            )
        
    def __init__(self, *args, **kwargs):
        super().__init__( *args, **kwargs)
        self.fields['phone'].required = False
        

class PhysicianRegForm(forms.ModelForm):
    password = forms.CharField(max_length=15, widget=forms.PasswordInput, label='Password:')
    password2 = forms.CharField(max_length=15, widget=forms.PasswordInput, label="Confirm Password:")
    class Meta:
        model = PhysicianModel
        fields = (
            'name',
            'email', 
            'phone',
        )

    def __init__(self, *args, **kwargs):
        super().__init__( *args, **kwargs)
        self.fields['phone'].required = Falseimport json
from django.contrib.auth.models import AbstractBaseUser, BaseUserManager
from django.db import models
from django.forms import ValidationError
from django.db.models import JSONField


class PatientManager(BaseUserManager):
    def create_user(self, email, name, phone, password=None, **extra_fields):
        if not email:
            raise ValueError('Email is required.')
        email = self.normalize_email(email)
        user = self.model(email=email, name=name, phone=phone, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, email, name, phone, password=None, **extra_fields):
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)
        return self.create_user(email, name, phone, password, **extra_fields)

class PatientModel(AbstractBaseUser):
    id = models.AutoField(primary_key = True)
    email = models.EmailField(unique=True,null = True)
    name = models.CharField(max_length=150,null = False)
    phone = models.CharField(max_length=15, null = True, default = None)
    records = models.JSONField(null = True)
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)

    

    objects = PatientManager()

    USERNAME_FIELD = 'name'
    REQUIRED_FIELDS = ['name', 'phone']

    def __str__(self):
        return self.name
    
    


class PhysicianManager(BaseUserManager):
    def create_user(self, email, name, phone, password=None, **extra_fields):
        if not email:
            raise ValueError('Email is required.')
        email = self.normalize_email(email)
        user = self.model(email=email, name=name, phone=phone, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, email, name, phone, password=None, **extra_fields):
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)
        return self.create_user(email, name, phone, password, **extra_fields)

    
class HealthCenterModel(models.Model):
    id = models.AutoField(primary_key= True)
    name = models.CharField(max_length=150, null = False)
    is_active = models.BooleanField(default=False)
    is_staff = models.BooleanField(default=False)
    av_rate = models.DecimalField(max_digits = 5, decimal_places = 4, null = True)
    recent_reviews = JSONField(blank = True, null = True)
    email = models.EmailField(null = True)

class PhysicianModel(AbstractBaseUser):
    id = models.AutoField(primary_key = True)
    hcId = models.ForeignKey(HealthCenterModel, default = 1, on_delete = models.CASCADE)
    email = models.EmailField(unique=True, null = True)
    name = models.CharField(max_length=150, null= True)
    phone = models.CharField(max_length=15, null = True)  
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)
    av_rate = models.DecimalField(max_digits = 5, decimal_places = 4, null = True)
    recent_reviews = JSONField(blank = True, null = True)


    objects = PhysicianManager()

    USERNAME_FIELD = 'name'
    REQUIRED_FIELDS = ['name', 'phone']

    def __str__(self):
        return self.name

    
from rest_framework import serializers
from . models import *


class PatientSerializer(serializers.ModelSerializer):
    class Meta:
        model = PatientModel
        fields = (
            'name',
            'email',
            'phone',
            'password'
        )


class PhysicianSerializer(serializers.ModelSerializer):
    class Meta:
        model = PhysicianModel
        fields = (
            'name',
            'email',
            'phone',
            'password'
        )from django.urls import path

from .import views

app_name = 'registration'

urlpatterns = [
    path('patient/', views.PatientRegistrationView.as_view(), name='patient_reg'),
    path('physician/', views.PhysicianRegistrationView.as_view(), name='physician_reg'),
]
from django.shortcuts import render, redirect
from django import views
from django.contrib.auth.hashers import make_password
from rest_framework.response import Response
from rest_framework.decorators import api_view
from rest_framework.views import APIView
from rest_framework import serializers


import requests

from .models import PatientModel, PhysicianModel
from .forms import PatientRegForm, PhysicianRegForm
from .authentication_backends import *



class PatientRegistrationView(APIView):
    def post(self, request):
        form = PatientRegForm(request.data)
        print(request.data['name'])
        if form.is_valid():
            # name = request.POST.get('name')
            # email = request.POST.get('email')
            # phone = request.POST.get('phone')
            # password1 = request.POST.get('password')
            # password2 = request.POST.get('password2')
            name = request.data['name']
            try:
                email = request.data['email']
            except:
                email = None
            try:
                phone = request.data['phone']
            except:
                phone = None
            password1 = request.data['password']
            password2 = request.data['password2']
            print(bool(phone))

            data = {
                'name': name,
                'email': email,
                'phone': phone,
                'password': password1
            }

            # Check if email or phone already exists
            if PatientModel.objects.filter(email=email).exists():
                message = 'The email is already taken.'
                return Response({'message': message})
            elif phone != None and PatientModel.objects.filter(phone=phone).exists():
                message = 'The phone number is already taken.'
                return Response({'message': message})
            else:
                if password1 == password2:
                    password_nw = make_password(password1) # To Hash the password
                    user = PatientModel.objects.create(name=name, email=email if email else None, phone=phone if phone else None, password=password_nw)
                    user.save()
                    send_Id = sendPatientId(user.id)

                    if send_Id == 200:
                        message = 'The id is succesfuly sent to the Arduino!'
                    else:
                        message = send_Id

                    return Response({'User data':data, 'Finger print Auth message':message}, status=200)
                else:
                    message = 'The passwords are not the same!'
                    return Response({'message': message})

        else:
            return Response({'Error message':form.errors})
        
def sendPatientId(user_id):
    try:
        endpoint = 'http://127.0.0.1:5000'
        res = requests.post(endpoint, json={'Patient_id':user_id})
        return res.status_code
    except:
        return 'There is an error comming from the server!'


# print(sendPatientId(2))



        

class PhysicianRegistrationView(APIView):
    def post(self, request):
        form = PhysicianRegForm(request.POST)
        if form.is_valid():
            name = request.POST.get('name')
            email = request.POST.get('email')
            phone = request.POST.get('phone')
            password1 = request.POST.get('password')
            password2 = request.POST.get('password2')

            data = {
                'name': name,
                'email': email,
                'phone': phone,
                'password': password1
            }

            if PhysicianModel.objects.filter(email=email).exists():
                message = 'The email is already taken.'
                return Response ({'message': message})
            elif phone != None and PhysicianModel.objects.filter(phone=phone).exists():
                message = 'The phone number is already taken.'
                return Response ({'message': message})
            else:
                if password1 == password2:
                    password_nw = make_password(password1)
                    user = PhysicianModel.objects.create(name=name, email=email, phone=phone, password=password_nw)
                    user.save()
                
                    return Response(data)
                else:
                    message = 'The passwords are not the same!'
                    return Response ({'message': form.errors})

        else:
            print(form.errors)
            print(form.errors.as_data())
            return Response({'Error message':form.errors})



def RegError(request):
    return render(request, '')

"""
Django settings for Fairmed_Backend project.

Generated by 'django-admin startproject' using Django 4.2.7.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/4.2/ref/settings/
"""

from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/4.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-9b0&jt)0nfp3!-4j*=fqf)km$a7*f4rt6^zhfez_yru#725(n9'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = [ "*" ]


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'home',
    'comment',
    'login',
    'registration',
    'search_engine',
    'rate_and_review',
    'medical_record',
    'corsheaders',
    'rest_framework',
    'django_filters'
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'corsheaders.middleware.CorsMiddleware',
]


CORS_ALLOW_ALL_ORIGINS = True
CORS_ALLOW_CREDENTIALS = True

CORS_ALLOWED_ORIGINS = [
    'http://localhost:3001', 
]

ROOT_URLCONF = 'Fairmed_Backend.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR, 'Templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'Fairmed_Backend.wsgi.application'


# Database
# https://docs.djangoproject.com/en/4.2/ref/settings/#databases
import os
from decouple import config

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': config('DB_NAME'),
        'USER': config('DB_USER'),
        'PASSWORD': config('DB_PASSWORD'),
        'HOST': config('DB_HOST'),
    }
}



# Password validation
# https://docs.djangoproject.com/en/4.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/4.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.2/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

MEDIA_ROOT = os.path.join(BASE_DIR, 'media/')

MEDIA_URL = '/media/'


AUTHENTICATION_BACKENDS = [
    'registration.authentication_backends.PatientAuthBackend',
    'registration.authentication_backends.PhysicianAuthBackend',
]

from rest_framework.settings import api_settings
from datetime import timedelta

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ],
    'UPDATE_LAST_LOGIN': True,
    'DEFAULT_FILTER_BACKENDS': ['django_filters.rest_framework.DjangoFilterBackend'],
    'DEFAULT_RENDERER_CLASSES': [
        'rest_framework.renderers.JSONRenderer',
        'rest_framework.renderers.TemplateHTMLRenderer',
        # Add other renderers as needed
    ],
}

SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(days=1),  
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),    
}

api_settings.UPDATE_LAST_LOGIN = True
